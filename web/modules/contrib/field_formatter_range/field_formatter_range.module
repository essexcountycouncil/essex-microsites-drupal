<?php

/**
 * @file
 * This module provides additional multivalued entity field options.
 */

declare(strict_types = 1);

use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Field\FormatterInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field_formatter_range\FieldFormatterRangeInterface;

/**
 * Implements hook_help().
 */
function field_formatter_range_help(string $route_name, RouteMatchInterface $route_match): string {
  $help = '';

  switch ($route_name) {
    case 'help.page.field_formatter_range':
      $help = '<p>' . \t('Enhances the field formatters with range and offset settings.') . '</p>';
  }

  return $help;
}

/**
 * Implements hook_field_formatter_third_party_settings_form().
 */
function field_formatter_range_field_formatter_third_party_settings_form(FormatterInterface $plugin, FieldDefinitionInterface $field_definition, string $view_mode, array $form, FormStateInterface $form_state): array {
  $element = [];
  $cardinality = 1;

  // Figure out the type of the field.
  if ($field_definition instanceof BaseFieldDefinition) {
    /** @var \Drupal\Core\Field\BaseFieldDefinition $field_definition */
    $cardinality = $field_definition->getCardinality();
  }
  elseif ($field_definition instanceof FieldConfig) {
    /** @var Drupal\field\Entity\FieldConfig $field_definition */
    $cardinality = $field_definition->getFieldStorageDefinition()->getCardinality();
  }

  // If only one value is provided the range has no meaning.
  if ($cardinality == 1) {
    return $element;
  }

  $element['order'] = [
    '#type' => 'select',
    '#title' => \t('Order'),
    '#options' => [
      FieldFormatterRangeInterface::ORDER_DEFAULT => \t('Default'),
      FieldFormatterRangeInterface::ORDER_REVERSE => \t('Reverse'),
      FieldFormatterRangeInterface::ORDER_RANDOM => \t('Random'),
    ],
    '#default_value' => $plugin->getThirdPartySetting('field_formatter_range', 'order', FieldFormatterRangeInterface::ORDER_DEFAULT),
    '#description' => \t('Controls the ordering of the displayed items.'),
  ];

  $element['limit'] = [
    '#type' => 'number',
    '#title' => \t('Display items'),
    '#default_value' => $plugin->getThirdPartySetting('field_formatter_range', 'limit', 0),
    '#required' => TRUE,
    '#min' => 0,
    '#max' => $cardinality == FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED ? 100 : $cardinality,
    '#description' => \t('Number of items to display. Set to 0 to display all items.'),
  ];

  $element['offset'] = [
    '#type' => 'number',
    '#title' => \t('Skip items'),
    '#default_value' => $plugin->getThirdPartySetting('field_formatter_range', 'offset', 0),
    '#required' => TRUE,
    '#min' => 0,
    '#description' => \t('Number of items to skip from the beginning.'),
  ];

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary_alter().
 *
 * @phpstan-ignore-next-line
 */
function field_formatter_range_field_formatter_settings_summary_alter(array &$summary, $context): void {
  // Display the range information.
  $cardinality = 1;

  // Figure out the type of the field.
  if ($context['field_definition'] instanceof BaseFieldDefinition) {
    $cardinality = $context['field_definition']->getCardinality();
  }
  elseif ($context['field_definition'] instanceof FieldConfig) {
    $cardinality = $context['field_definition']->getFieldStorageDefinition()->getCardinality();
  }

  // If only one value is provided the range has no meaning.
  if ($cardinality == 1) {
    return;
  }

  // Get the settings.
  $order = $context['formatter']->getThirdPartySetting('field_formatter_range', 'order', 0);
  $offset = $context['formatter']->getThirdPartySetting('field_formatter_range', 'offset', 0);
  $limit = $context['formatter']->getThirdPartySetting('field_formatter_range', 'limit', 0);

  // Create the message.
  if (!empty($order) && $order == FieldFormatterRangeInterface::ORDER_REVERSE) {
    $message = (empty($limit) || $limit == $cardinality)
      ? \t('Display all items in reversed order.')
      : \Drupal::translation()->formatPlural($limit, 'Display 1 item in reversed order.', 'Display @n items in reversed order.', ['@n' => $limit]);
  }
  elseif (!empty($order) && $order == FieldFormatterRangeInterface::ORDER_RANDOM) {
    $message = (empty($limit) || $limit == $cardinality)
      ? \t('Display all items in random order.')
      : \Drupal::translation()->formatPlural($limit, 'Display 1 item in random order.', 'Display @n items in random order.', ['@n' => $limit]);
  }
  else {
    $message = (empty($limit) || $limit == $cardinality)
      ? \t('Display all items.')
      : \Drupal::translation()->formatPlural($limit, 'Display 1 item.', 'Display @n items.', ['@n' => $limit]);
  }

  if (!empty($offset)) {
    $message .= ' ' . \t('Offset by @n.', ['@n' => $offset]);
  }

  // Display the information.
  $summary[] = $message;
}

/**
 * Implements hook_preprocess_field().
 */
function field_formatter_range_preprocess_field(array &$variables): void {
  if (isset($variables['element']['#third_party_settings']['field_formatter_range'])) {
    $rangeSettings = $variables['element']['#third_party_settings']['field_formatter_range'];

    \field_formatter_range_apply_settings($rangeSettings, $variables['items']);
  }
}

/**
 * Apply the field_formatter_range settings to content array.
 *
 * @param array $settings
 *   The field formatter range settings.
 * @param array|null $field_content
 *   The field's content.
 */
function field_formatter_range_apply_settings(array $settings, &$field_content): void {
  $order = !empty($settings['order']) ? (int) $settings['order'] : 0;
  $offset = !empty($settings['offset']) ? (int) $settings['offset'] : 0;
  $limit = !empty($settings['limit']) ? (int) $settings['limit'] : 0;

  // Set limit to NULL so we can work only with offset if needed.
  if ($limit == 0) {
    $limit = NULL;
  }

  $field_content = ($field_content === NULL) ? [] : $field_content;

  $children = $children_cp = Element::children($field_content);

  // Reverse them if needed.
  if (!empty($order) && $order == FieldFormatterRangeInterface::ORDER_REVERSE) {
    $children = \array_reverse($children);
  }
  elseif (!empty($order) && $order == FieldFormatterRangeInterface::ORDER_RANDOM) {
    \shuffle($children);
  }

  // Process items accordingly if offset or limit is set.
  if (!empty($offset) || !empty($limit)) {
    $children = \array_slice($children, $offset, $limit);
  }

  // If any of the settings is enabled we'll process the items
  // since deltas have to start from 0, and we already have
  // the proper items in proper order.
  if (!empty($order) || !empty($offset) || !empty($limit)) {
    // Get the items we'll display.
    $items = [];

    foreach ($children as $child) {
      $items[] = $field_content[$child];
    }

    // Remove all the existing items so we can display only
    // the ones we want.
    foreach ($children_cp as $child) {
      unset($field_content[$child]);
    }

    // Put the items that we want to display back into the display.
    $field_content += $items;
  }
}
